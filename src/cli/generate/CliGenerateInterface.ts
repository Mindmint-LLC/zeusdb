import { CliGenerateBase } from './CliGenerateBase';
import { ZeusDB } from '../../library/ZeusDB';
import { ResultRow } from '../../types/ZeusTypes';
import fs from 'node:fs';
import path from 'node:path';
import { ICliCommandProfileGenerate } from './index';

export class CliGenerateInterface extends CliGenerateBase {

  constructor() {
    super();
  }


  public async generateSingleFileInterface() {

    const commandProfile = this.commandProfile as ICliCommandProfileGenerate;

    // generate a single file with all the interfaces
    console.log(`Generating single file with all interfaces for datasource ${commandProfile.datasource}...`);


    const outputPath = commandProfile.output;
    if (!outputPath) {
      throw new Error(`Cli.Generate: No output path found for datasource ${commandProfile.datasource}...`);
    }

    // Get Datasource
    const dataSourceName = commandProfile.datasource ?? '';
    const dataSourceConfig = this.config.datasources[dataSourceName];
    if (!dataSourceConfig) {
      throw new Error(`Cli.Generate: No datasource found for ${dataSourceName}...`);
    }

    const ds = ZeusDB.registerDataSource(dataSourceConfig, commandProfile.schema);
    const conn = await ZeusDB.connect(ds.id);

    // Generate Interfaces using the datasource (try to keep it database agnostic)
    const tables = ((await conn.query`
        SHOW TABLES;
      `) as ResultRow[])
      .map((row: any) => row[Object.keys(row)[0]])
      .filter((table: string) => !table.startsWith('_prisma'))
    ;
    console.log(`Found ${tables.length} tables`);

    let output = `import {type ResultRow } from "zeusdb";\n\n`;
    output += `// Generated by ZeusDB : Do not edit directly, changes may be lost.\n\n`;

    const enums = new Map<string, any>();

    for (let table of tables) {
      if (!/^[a-zA-Z0-9_]+$/.test(table)) {
        continue;
      }
      const columns:ResultRow[]|Error = await conn.query(`
          SHOW COLUMNS FROM ${table};
        `)
      ;
      if (columns instanceof Error) {
        console.error(`Cli.Generate: Error getting columns for ${table}`, columns);
        continue;
      }

      const interfaceName = (commandProfile.interfacePrefix ? commandProfile.interfacePrefix + table.substr(0,1).toUpperCase() + table.substr(1) : table);
      output += `export interface ${interfaceName} extends ResultRow {\n`;
      let column:any;
      for (column of columns) {
        const colName = column.Field;
        const colType = column.Type;
        const colNull = column.Null;
        const colKey = column.Key;
        const colDefault = column.Default;
        const colExtra = column.Extra;
        const colTypeBase = colType.toLowerCase().split('(')[0];

        let fieldType = this.getFieldTypeFromColumnType(colTypeBase);

        if (colTypeBase === 'enum') {
          // capitalize the first letter - enum name
          fieldType = (commandProfile.enumPrefix ? commandProfile.enumPrefix + colName.substr(0,1).toUpperCase() + colName.substr(1) : colName);

          enums.set(fieldType, {
            name: fieldType,
            values: colType.match(/'([^']+)'/g)?.map((v:string) => v.replace(/'/g, '')) ?? [],
          });
        }

        if (commandProfile.showFieldComments) {
          output += `  /** ${table}.${colName} - ${colType}${colNull == 'YES' ? ' nullable' : ''}${colKey == 'PRI' ? ' PRIMARY KEY' : ''}${colDefault ? ` (default ${colDefault})` : ''}${colExtra ? ` ${colExtra}` : ''} */\n`;
        }
        output += `  ${colName}?: ${fieldType};\n`;
        if (commandProfile.showFieldComments) {
          output += `\n`;
        }
      }
      output += `}\n\n`;
      if (commandProfile.showFieldComments) {
        output += `\n`;
      }
    }

    console.log(`Found ${enums.size} enums`);
    for (let enumItem of enums.values()) {
      output += `export enum ${enumItem.name} {\n`;
      for (let value of enumItem.values) {
        output += `  ${value} = '${value}',\n`;
      }
      output += `}\n\n`;
    }

    // remove the last newline(s)
    output = output.trim();
    await conn.close();
    await ZeusDB.disconnectAll();

    // save the output to a file

    try {
      const filePath = path.resolve(this.workingDir, outputPath);
      fs.writeFileSync(filePath, output);
    } catch (err) {
      console.error(`Cli.Generate: Error writing to file ${outputPath}`, err);
      return;
    }

    console.log("Interface file generated successfully");

  }


}